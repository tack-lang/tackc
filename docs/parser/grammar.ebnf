(*
    NOTE: This is a spec grammar, not a parsing grammar. 
    This grammar does not encode precedence or associativity, and is heavily ambiguous.
*)

Prog = ModStmt Item* ;

ModStmt = MOD Path SEMICOLON ;

Stmt = Item
    | LetStmt
    | ExprStmt
    ;

LetStmt = LET IDENTIFIER ( COLON Expr )? ( EQ Expr )? SEMICOLON ;
ExprStmt = Expr SEMICOLON ;

Item = ConstItem
    | FuncItem
    ;

ConstItem = Visibility CONST IDENTIFIER ( COLON Expr )? ( EQ Expr )? SEMICOLON ;
FuncItem = Visibility FUNC IDENTIFIER OPEN_PAREN ParameterList? CLOSE_PAREN ExprNB? Block ;

Visibility = EXP? ;

ParameterList = IDENTIFIER COLON Expr ( COMMA IDENTIFIER COLON Expr )* COMMA? ;

Expr = Primary
    | Infix
    | Prefix
    | Grouping
    | Postfix
    | Block
    ;

Postfix = MemberAccess
    | Call
    | Index
    ;
Infix = Expr InfixOp Expr ;
Prefix = PrefixOp Expr ;
Grouping = L_PAREN Expr R_PAREN ;

MemberAccess = Expr DOT IDENTIFIER ;
Call = Expr L_PAREN ArgumentList? R_PAREN ;
Index = Expr L_BRACKET Expr R_BRACKET ;
Block = L_BRACE Stmt* Expr? R_BRACE ;

ArgumentList = Expr ( COMMA Expr )* COMMA? ;

(*
    Expressions that can't be confused with expressions that are followed by blocks, or blocks themselves.
    If statements are allowed, since 'if' isn't a valid expression.
    Struct declarations aren't allowed, since 'struct' is a valid expression.
*)
ExprNB = Primary
    | InfixNB
    | PrefixNB
    | Grouping (* Can contain blocks *)
    | PostfixNB
    ;

PostfixNB = MemberAccessNB
    | CallNB
    | IndexNB
    ;
InfixNB = ExprNB InfixOp ExprNB ;
PrefixNB = PrefixOp ExprNB ;
(* No GroupingNB *)
MemberAccessNB = ExprNB DOT IDENTIFIER ;
CallNB = ExprNB L_PAREN ArgumentList? R_PAREN ; (* No ArgumentListNB *)
IndexNB = ExprNB L_BRACKET Expr R_BRACKET ; (* Uses Expr inside brackets *)

InfixOp = PLUS | DASH | STAR | SLASH | EQ_EQ | BANG_EQ | GT | LT | GT_EQ | LT_EQ ;
PrefixOp = PLUS | DASH ;

Primary = IDENTIFIER
    | U8
    | U16
    | U32
    | U64
    | I8
    | I16
    | I32
    | I64
    | INT_LIT
    | FLOAT_LIT
    ;

Path = IDENTIFIER ( DOT IDENTIFIER )* ;

(*
    Operators (in precedence order, lowest to highest):
    Comparison (<, >, <=, >=, ==, !=, left-associative)

    Term (+, -, left-associative)

    Factor (*, /, left-associative)

    Prefix (+, -, right-associative)

    Postfix ([, (, .,  left-associative)
*)

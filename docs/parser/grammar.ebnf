(*
    NOTE: This is a spec grammar, not a parsing grammar. 
    This grammar does not encode precedence or associativity, and is heavily ambiguous.
*)

Stmt = LetStmt
    | ExprStmt
    ;

LetStmt = LET IDENTIFIER ( COLON Expr )? ( EQ Expr )? SEMICOLON ;
ExprStmt = Expr SEMICOLON ;

Expr = Primary
    | Infix
    | Prefix
    | Grouping
    | Postfix
    ;

Postfix = MemberAccess
    | Call
    | Index
    | Block
    ;
Infix = Expr InfixOp Expr ;
Prefix = PrefixOp Expr ;
Grouping = L_PAREN Expr R_PAREN ;

MemberAccess = Expr DOT IDENTIFIER ;
Call = Expr L_PAREN ArgumentList? R_PAREN ;
Index = Expr L_BRACKET Expr R_BRACKET ;
Block = L_BRACE Stmt* Expr? R_BRACE ;

ArgumentList = Expr ( COMMA Expr )* COMMA? ;

(* Expressions that can't be ambiguous to expressions followed by blocks *)
ExprNB = Primary
    | InfixNB
    | PrefixNB
    | Grouping (* Can contain blocks *)
    | PostfixNB
    ;

PostfixNB = MemberAccessNB
    | CallNB
    | IndexNB
    ;
InfixNB = ExprNB InfixOp ExprNB ;
PrefixNB = PrefixOp ExprNB ;
(* No GroupingNB *)
MemberAccessNB = ExprNB DOT IDENTIFIER ;
CallNB = ExprNB L_PAREN ArgumentList? R_PAREN ; (* No ArgumentListNB *)
IndexNB = ExprNB L_BRACKET Expr R_BRACKET ; (* Uses Expr inside brackets *)

InfixOp = PLUS | DASH | STAR | SLASH | EQ_EQ | BANG_EQ | GT | LT | GT_EQ | LT_EQ ;
PrefixOp = PLUS | DASH ;

Primary = Literal
    | IDENTIFIER
    ;

Literal = INT_LIT
    | FLOAT_LIT
    ;

Path = IDENTIFIER ( DOT IDENTIFIER )* ;

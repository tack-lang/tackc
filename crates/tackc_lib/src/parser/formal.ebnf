Program = ModStatement Item* ;

ModStatement = MOD Path SEMICOLON ;

Item = ConstItem
    | FuncItem
    ;
ConstItem = Visibility CONST IDENTIFIER ( COLON Expression )? EQ Expression SEMICOLON ;
(* 
    The Expression right before the block is the 'return type',
    which may not syntactically contain a valid expression followed by an L_BRACE, or start with an L_BRACE.

    EXAMPLES:
        struct { ... }
            INVALID: `struct` is a valid expression, and is followed by an L_BRACE.
        if true { ... }
            VALID: `if true` is not a valid expression.
        { ... }
            INVALID: starts with an L_BRACE.
*)
FuncItem = Visibility FUNC IDENTIFIER L_PAREN ParamList? R_PAREN Expression? Block ;
ParamList = ( IDENTIFIER COLON Expression ) ( COMMA IDENTIFIER COLON Expression )* COMMA? ;
ImpItem = IMP Path SEMICOLON ;

Visibility = EXP? ;

Block = L_BRACE Statement* Expression? R_BRACE ;

Statement = LetStatement
    | ExpressionStatement
    | Item
    | AssignmentStatement
    ;
LetStatement = LET IDENTIFIER ( COLON Expression )? ( EQ Expression )? SEMICOLON ;
(* 
    The ending semicolon is only optional if the expression ends with a block, and it returns void.
    The first requirement is too difficult to describe with a grammar.
    This second requirement cannot be verified in parsing, so it's verified later.
*)
ExprStmt = Expression SEMICOLON? ;
(*
    Not every expression can go into the left hand side of AssignmentStatement, but this can be verified later.
*)
AssignmentStatement = Expression EQ Expression SEMICOLON ;

Expression = Comparison ;
Comparison = Term ( ( GT | LT | GT_EQ | LT_EQ | EQ_EQ | BANG_EQ ) Term )?
Term = Factor ( ( PLUS | MINUS ) Factor )* ;
Factor = Unary ( ( STAR | SLASH ) Unary )* ;

Unary = ( MINUS | BANG ) Unary
    | Postfix
    ;
Postfix = Grouping (L_PAREN ArgList? R_PAREN
    | L_BRACKET Expression R_BRACKET
    | DOT IDENTIFIER)* ;
Grouping = L_PAREN Expression R_PAREN
    | BlockExpression ;
BlockExpression = Block
    | GlobalIdentifier ;
GlobalIdentifier = DOT IDENTIFIER
    | Primary ;
Primary = IDENTIFIER
    | INT_LIT
    | FLOAT_LIT
    ;

ArgList = Expression ( COMMA Expression )* COMMA? ;

Path = IDENTIFIER ( DOT IDENTIFIER )* ;

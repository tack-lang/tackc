Item = ConstItem ;
ConstItem = CONST IDENTIFIER ( COLON Expression )? EQ Expression SEMICOLON ;

Stmt = LetStmt
    | ExprStmt
    | Item
    ;
LetStmt = LET IDENTIFIER ( COLON Expression )? ( EQ Expression )? SEMICOLON ;
(* 
    The ending semicolon is only optional if the expression ends with a block, and it returns void.
    The first requirement is too difficult to describe with a grammar.
    This second requirement cannot be verified in parsing, so it's verified later.
*)
ExprStmt = Expr SEMICOLON? ;

Expression = Comparison ;
Comparison = Term ( ( GT | LT | GT_EQ | LT_EQ | EQ_EQ | BANG_EQ ) Term )?
Term = Factor ( ( PLUS | MINUS ) Factor )* ;
Factor = Unary ( ( STAR | SLASH ) Unary )* ;

Unary = ( MINUS | BANG ) Unary
    | Postfix
    ;
Postfix = Grouping (L_PAREN ArgList? R_PAREN
    | L_BRACKET Expression R_BRACKET
    | DOT IDENTIFIER)* ;
Grouping = L_PAREN Expression R_PAREN
    | Primary ;
Primary = IDENTIFIER
    | INT_LIT
    | FLOAT_LIT
    ;

ArgList = Expression ( COMMA Expression )* COMMA? ;
